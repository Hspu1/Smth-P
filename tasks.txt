DI повсеместно
ИСПРАВЬ КОД СОГЛАСНО RUFF И MYPY ig
CheckConstraint

тг бот пишет об успешном входе и тд реакции на соо
секьюрити мидлвары и на фронтенде сделай все жирно и только то что надо

Bfcache fix: Очистка htmx-request через window.onpageshow, чтобы лоадер не «залипал» при нажатии кнопки «Назад».
Layout: Переезд на display: grid для кнопок, чтобы на мобилках они не превращались в кашу.

комменты жоска с трай эксепт
полиш код, рэббит, мануал ауф, мануал связывание акков
хули локалтуннель умирает
ридмишку по красоте оформи

максимальная безопасность по типу трай эксепт ретраем мидлвар и тому подобное
инкапсулируй данные вынеси в env
и в лайфспане обязательно пингуй редис до старта

замени хардкод на stg





апдейтед ап как вообще происходит если почта одна и та же
FU с комментами жестко бля


from sqlalchemy.ext.asyncio import (
    create_async_engine, async_sessionmaker, AsyncSession, AsyncEngine
)

class PostgresService:
    def __init__(self):
        self._engine: AsyncEngine | None = None
        self._session_maker: async_sessionmaker[AsyncSession] | None = None

    def init_state(self, db_url: str):
        self._engine = create_async_engine(
            db_url,
            pool_pre_ping=True,
            pool_recycle=3600,
            pool_size=10,
            max_overflow=20,
            # В High Load полезно добавить таймаут, чтобы не вешать воркеры
            connect_args={"command_timeout": 10}
        )
        self._session_maker = async_sessionmaker(
            bind=self._engine,
            class_=AsyncSession,
            expire_on_commit=False
        )

    @property
    def session_maker(self) -> async_sessionmaker[AsyncSession]:
        if self._session_maker is None:
            raise RuntimeError("PostgresService isn't initialized")
        return self._session_maker

    async def aclose(self):
        if self._engine:
            await self._engine.dispose()

postgres_service = PostgresService()


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    # Инфо: Redis init...
    # DB init:
    db_url = stg.db_url if not getattr(app.state, "testing", False) else stg.test_db_url
    postgres_service.init_state(db_url)

    yield

    await redis_service.aclose()
    await postgres_service.aclose() # КРИТИЧНО для закрытия пула


DI

from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import AsyncSession

# ... внутри или рядом с PostgresService ...

async def get_session() -> AsyncGenerator[AsyncSession, None]:
    """
    Зависимость для FastAPI.
    Гарантирует закрытие сессии после выполнения запроса.
    """
    async with postgres_service.session_maker() as session:
        try:
            yield session
            # Если нужно автоматически коммитить каждый успешный запрос:
            # await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()



from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.infra.postgres.service import get_session

async def google_callback_handling(
    request: Request,
    db: AsyncSession = Depends(get_session) # Магия DI здесь
) -> RedirectResponse:
    # ... логика получения токена ...

    # Теперь передаем сессию в логику поиска/создания юзера
    user_id = await get_user_id(
        session=db, # Передаем сессию дальше
        user_info=user_info,
        provider=AuthProvider.GOOGLE,
        provider_user_id=user_info_id
    )

    # ... запись в request.session и редирект ...


ЧИТАЙ ЗДЕСЬ + В ТГ НИЧЕГО НЕ УДАЛЯЙ
лимитер на уровне редиске etc чек ai чат на эту тему


# app/api/auth/service.py

async def get_user_id(session: AsyncSession, user_info: dict, provider: str, provider_user_id: str) -> str:
    user = await get_or_create_user(session, provider, provider_user_id, user_info)
    return str(user.id)


from sqlalchemy import select
from sqlalchemy.orm import joinedload
from sqlalchemy.ext.asyncio import AsyncSession
from app.infra.postgres.models import UsersModel, UserIdentitiesModel

async def get_or_create_user(
    session: AsyncSession,
    provider: str,
    provider_user_id: str,
    user_info: dict
) -> UsersModel:
    # 1. Ищем существующую идентичность вместе с юзером (один запрос!)
    stmt = (
        select(UserIdentitiesModel)
        .options(joinedload(UserIdentitiesModel.user))
        .where(
            UserIdentitiesModel.provider == provider,
            UserIdentitiesModel.provider_user_id == provider_user_id
        )
    )
    result = await session.execute(stmt)
    identity = result.scalar_one_or_none()

    if identity:
        return identity.user

    # 2. Если не нашли — создаем нового юзера
    # Благодаря flush(), SQLA получит ID юзера (uuid7), не завершая транзакцию
    new_user = UsersModel(
        email=user_info["email"],
        full_name=user_info.get("name") or user_info.get("given_name", "Unknown")
    )
    session.add(new_user)
    await session.flush()

    # 3. Привязываем идентичность (Google/Github и т.д.)
    new_identity = UserIdentitiesModel(
        user_id=new_user.id,
        provider=provider,
        provider_user_id=provider_user_id
    )
    session.add(new_identity)

    # Фиксируем всё одним махом
    await session.commit()
    return new_user

Если StackOverflow вдруг вернет ошибку (например, code уже использован),
res.text может не быть строкой запроса. Всегда проверяй access_token перед тем,
как делать stackoverflow_oauth.stackoverflow.get. Но в целом структура верная.

asyncio lock
